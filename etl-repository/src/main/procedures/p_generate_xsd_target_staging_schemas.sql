create or replace procedure p_generate_xsd_target_staging_schemas()
language plpgsql
as $procedure$
declare 
	l_rec record;
	l_is_etl_role_used boolean := case when length('${etlUserRole}') > 0 then true else false end;
begin
	for l_rec in (
		select
			t.*
			, case when target_schema.nspname is null then false else true end as is_target_staging_schema_exists
			, coalesce(schema_usage_permission.has_schema_usage_permission, false) as is_etluser_has_schema_usage_permission
		from 
			${mainSchemaName}.v_xsd_transformation t
		join ${mainSchemaName}.xsd_transformation xsd_transformation 
			on xsd_transformation.id = t.id
		left join pg_catalog.pg_namespace target_schema
			on target_schema.nspname = t.target_staging_schema
		left join lateral (
			select
				true as has_schema_usage_permission
			from
				pg_catalog.aclexplode(target_schema.nspacl) acl
			join pg_catalog.pg_user grantee 
				on acl.grantee = grantee.usesysid
				and grantee.usename = '${etlUserRole}'
			where 
				acl.privilege_type = 'USAGE'
		) schema_usage_permission on true
		where 
			coalesce(t.is_staging_schema_generated, false) = false
		order by 
			t.internal_name
			, t.version
		for update of xsd_transformation
	) 
	loop
		raise notice 'Generating schema %...', l_rec.target_staging_schema;
	
		if not l_rec.is_target_staging_schema_exists then
			execute format('create schema %I', l_rec.target_staging_schema);
		end if;
	
		if l_is_etl_role_used 
			and not l_rec.is_etluser_has_schema_usage_permission
		then
			execute	
				format(
					'grant usage on schema %I to ${etlUserRole}'
					, l_rec.target_staging_schema 
				);
		end if;
	
		call ${mainSchemaName}.p_extract_xsd_entities(
			i_xsd_transformation_id => l_rec.id
		);

		call ${mainSchemaName}.p_extract_xsd_entity_attributes(
			i_xsd_transformation_id => l_rec.id
		);
	
		execute 
			format('
				create table if not exists %I._data_package(
					id ${type.id} not null primary key generated by default as identity
					, xsd_transformation_id ${type.id} not null references ${mainSchemaName}.xsd_transformation(id)
					, external_id ${type.code} not null
					, load_date timestamp not null
				);
	
				create index if not exists i_data_package$xsd_transformation_id on %I._data_package(xsd_transformation_id);
				create unique index if not exists ui_data_package$external_id on %I._data_package(external_id);

				comment on table %I._data_package is $comment$Пакеты данных$comment$;
				comment on column %I._data_package.id is $comment$Идентификатор пакета данных$comment$;
				comment on column %I._data_package.xsd_transformation_id is $comment$Идентификатор трансформации XSD$comment$;
				comment on column %I._data_package.external_id is $comment$Внешний идентификатор пакета данных$comment$;
				comment on column %I._data_package.load_date is $comment$Дата загрузки$comment$;
				'
				, l_rec.target_staging_schema
				, l_rec.target_staging_schema 
				, l_rec.target_staging_schema				
				, l_rec.target_staging_schema
				, l_rec.target_staging_schema
				, l_rec.target_staging_schema
				, l_rec.target_staging_schema
				, l_rec.target_staging_schema
			);	
	
		if l_is_etl_role_used
		then
			execute	
				format(
					'grant select, insert, update, delete, truncate on %I._data_package to ${etlUserRole}'
					, l_rec.target_staging_schema
				);
		end if;

		call ${mainSchemaName}.p_generate_xsd_target_staging_tables(
			i_xsd_transformation_id => l_rec.id
		);

		update ${mainSchemaName}.xsd_transformation 
		set is_staging_schema_generated = true
		where id = l_rec.id
		;
	end loop;
end
$procedure$;			
